\begin{frame}
    \frametitle{BDD-Based SSAT Solving}
    {
        \small
        \begin{algorithmic}[1]
            \REQUIRE An ROBDD node $N$ and a prefix $Q$
            \ENSURE $\spb{N=\top}$ under $Q$
            \IF{($N$ is a terminal node)}
            \RETURN $\nodesp{N}$
            \ENDIF
            \IF{($\nodevisit{N}=\false$)}
            \IF{($Q(\nodevar{N})=\random{p}$)}
            \alert{\STATE $\nodesp{N}:=(1-p)\cdot\texttt{BddSsatRecur}(\nodeelse{N},Q)+p\cdot\texttt{BddSsatRecur}(\nodethen{N},Q)$}
            \ELSE
            \alert{\STATE $\nodesp{N}:=\max\{\texttt{BddSsatRecur}(\nodeelse{N},Q),\texttt{BddSsatRecur}(\nodethen{N},Q)\}$}
            \ENDIF
            \STATE $\nodevisit{N} := \true$
            \ENDIF
            \RETURN $\nodesp{N}$
        \end{algorithmic}
    }
\end{frame}

\begin{frame}
    \frametitle{Rewriting WMC into Unweighted MC}
    \begin{block}{Example: WMC Rewriting}
        Express $p_{z_1}=0.25$ with $z_1\equiv z_2\land z_3$:
        \begin{figure}
            \centering
            \input{prob-design-eval/rewriting.tex}
        \end{figure}
        \begin{itemize}
            \item Unweighted: $p_{x_1}=p_{x_2}=p_{x_3}=p_{z_2}=p_{z_3}=0.5$
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{WMC Rewriting Procedure}
    {
        \scriptsize
        \begin{algorithmic}[1]
            \REQUIRE A formula $\pf$, a base set $\base$ for $\pf$,
            a wt. func. $\wt$ s.t. $\forall x\in\base.\wt(x)=\frac{k}{2^n}$
            \ENSURE A formula $\pf'$, a base set $\base'$ for $\pf'$,
            a wt. func. $\wt'$ s.t. $\forall x\in\base'.\wt'(x)=\frac{1}{2}$
            \STATE $\pf':=\pf,\base':=\base$
            \FORALL{($x\in\base$)}
            \STATE $var:=x,wt:=\wt(x)$
            \WHILE{($wt\neq\frac{1}{2}$)}
            \STATE $inv:=\bot$
            \IF{($wt>\frac{1}{2}$)}
            \STATE $wt:=1-wt,inv:=\top$
            \ENDIF
            \STATE $\pf':=\pf'\land((inv \oplus var) \equiv (y_{var} \land z_{var}))$
            \STATE $\base':=\base'\setminus\{var\}\cup\{y_{var}\}$
            \STATE $\wt'(y_{var})=\frac{1}{2}$
            \STATE $var=z_{var},wt=2 \cdot wt$
            \ENDWHILE
            \STATE $\base':=\base'\cup\{var\},\wt'(var)=\frac{1}{2}$
            \ENDFOR
            \RETURN $(\pf',\base',\wt')$
        \end{algorithmic}
    }
\end{frame}

\begin{frame}
    \frametitle{Results for PEC ($\dr=0.1$)}
    \begin{table}
        \centering
        \tiny
        \pgfplotstabletypeset[
            every head row/.style={before row={\toprule
                            & \multicolumn{4}{c}{\bddsp} & \multicolumn{4}{c}{\dcssat} & \multicolumn{4}{c}{\cachet} & \multicolumn{4}{c}{\approxmc}\\},after row=\midrule},
            every last row/.style={after row=\bottomrule},
            empty cells with={--},
            circuit column/.list={0},
            time column/.list={1,3,5,7},
            prob column/.list={2,4,6,8}
        ]
        {prob-design-eval/parsed-PEC-D-0.10.csv}
    \end{table}
\end{frame}

\begin{frame}
    \frametitle{Results for MPEC ($\dr=0.1$)}
    \begin{table}
        \centering
        \tiny
        \pgfplotstabletypeset[
            every head row/.style={before row={\toprule
                            & \multicolumn{4}{c}{\bddsp} & \multicolumn{4}{c}{\bddspnr} & \multicolumn{4}{c}{\dcssat}\\},after row=\midrule},
            every last row/.style={after row=\bottomrule},
            empty cells with={--},
            circuit column/.list={0},
            time column/.list={1,3,5},
            prob column/.list={2,4,6}
        ]
        {prob-design-eval/parsed-MPEC-D-0.10.csv}
    \end{table}
\end{frame}

\begin{frame}
    \frametitle{Generalization of SAT Minterms}
    \begin{block}{Example: SAT Generalization}
        Consider $\random{0.5}r_1,\random{0.5}r_2,\random{0.5}r_3,\exists e_1,\exists e_2,\exists e_3.\pf$ with $\pf$ consisting of the following clauses, and $\as=\lnot r_1r_2r_3$:
        \begin{itemize}
            \item[] $C_1: (r_1 \lor r_2 \lor e_1)$; $C_2: (r_1 \lor \lnot r_3 \lor e_2)$; $C_3: (r_2 \lor \lnot r_3 \lor \lnot e_1 \lor \lnot e_2)$
            \item[] $C_4: (r_3 \lor e_3)$; $C_5: (r_3 \lor \lnot e_3)$
        \end{itemize}
        \begin{itemize}
            \item $\as$ is a SAT minterm: $\pf$ is satisfiable with $\as$ and $\mu=\lnot e_1e_2\lnot e_3$
            \item Generalize $\as$ to a SAT cube $\as^+=r_2r_3$
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Generalization of UNSAT Minterms}
    \begin{block}{Example: UNSAT Generalization}
        Consider $\random{0.5}r_1,\random{0.5}r_2,\random{0.5}r_3,\exists e_1,\exists e_2,\exists e_3.\pf$ with $\pf$ consisting of the following clauses, and $\as=\lnot r_1\lnot r_2\lnot r_3$:
        \begin{itemize}
            \item[] $C_1: (r_1 \lor r_2 \lor e_1)$; $C_2: (r_1 \lor \lnot r_3 \lor e_2)$; $C_3: (r_2 \lor \lnot r_3 \lor \lnot e_1 \lor \lnot e_2)$
            \item[] $C_4: (r_3 \lor e_3)$; $C_5: (r_3 \lor \lnot e_3)$
        \end{itemize}
        \begin{itemize}
            \item $\as$ is an UNSAT minterm: $C_4$ and $C_5$ conflict
            \item Generalize $\as$ to an UNSAT cube $\as^+=\lnot r_3$
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{RE-SSAT Solving}
    {\scriptsize
        \begin{algorithmic}[1]
            \REQUIRE
            $\Qf=\random{} X,\exists Y.\pf(X,Y)$ and a run-time limit \timeout
            \ENSURE
            Lower and upper bounds $(P_L,P_U)$ of $\spb{\Qf}$
            \STATE $\select(X) := \top$
            \STATE $C_\top := \emptyset$
            \STATE $C_\bot := \emptyset$
            \WHILE{($\sat{\select}$ \textbf{and} $\texttt{run-time} < \timeout$)}
            \STATE $\as := \model{\select}$
            \IF{($\sat{\pcf{\pf}{\as}}$)}
            \STATE $\as^+ := \texttt{MinimalSatisfying}(\pf,\as)$
            \STATE $C_\top := C_\top \cup \{\as^+\}$
            \ELSE
            \STATE $\as^+ := \texttt{MinimalConflicting}(\pf,\as)$
            \STATE $C_\bot := C_\bot \cup \{\as^+\}$
            \ENDIF
            \STATE $\select := \select \land \lnot\as^+$
            \ENDWHILE
            \RETURN $(\texttt{ComputeWeight}(C_\top),1-\texttt{ComputeWeight}(C_\bot))$
        \end{algorithmic}
    }
\end{frame}

\begin{frame}
    \frametitle{Results for PEC Formulas ($\dr=0.1$)}
    \begin{table}[ht]
        \centering
        \tiny
        \pgfplotstabletypeset[
            every head row/.style={before row={\toprule
                            & \multicolumn{4}{c}{\dcssat} & \multicolumn{6}{c}{\ressat} & \multicolumn{6}{c}{\ressatb}\\},after row=\midrule},
            every last row/.style={after row=\bottomrule},
            empty cells with={--},
            formula column/.list={0},
            time column/.list={1,3,6},
            prob column/.list={2,4,7},
            ubound column/.list={5,8}
        ]
        {random-exist-ssat/parsed-PEC-0.10.csv}
    \end{table}
\end{frame}

\begin{frame}
    \frametitle{Minimal Clause Selection}
    \begin{itemize}
        \item Iteratively solve $\select(X,S)$ to select a minimal set of clauses
        \item Recall $\Qf=\exists e_1,\exists e_2,\exists e_3,\random{0.5} r_1,\random{0.5} r_2,\random{0.5} r_3.\pf$ with
              \begin{itemize}
                  \item[] $C_1: (e_1 \lor r_1 \lor r_2)$ $C_2: (e_1 \lor e_2 \lor r_1 \lor r_2 \lor \lnot r_3)$
                  \item[] $C_3: (\lnot e_2 \lor \lnot e_3 \lor r_2 \lor \lnot r_3)$ $C_4: (\lnot e_1 \lor e_3 \lor r_3)$
              \end{itemize}
        \item $\as_1=\lnot e_1 \lnot e_2 \lnot e_3$ selects $\{C_1,C_2\}$
        \item Solve $\select\land(\lnot s_1\lor\lnot s_2)$ under assumptions $s_3\land s_4$
              \begin{itemize}
                  \item $\as_2=\lnot e_1 e_2 \lnot e_3$, which only selects $\{C_1\}$
                  \item Replace an expensive model-counting call with a SAT call
              \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Induced Clause Subsumption}
    \begin{itemize}
        \item $C_1$ subsumes $C_2$ if $C_1 \subseteq C_2$ (treat $C_1$ and $C_2$ as sets of literals)
        \item Subsumed clauses can be removed from a CNF formula
        \item Recall $\Qf=\exists e_1,\exists e_2,\exists e_3,\random{0.5} r_1,\random{0.5} r_2,\random{0.5} r_3.\pf$ with
              \begin{itemize}
                  \item[] $C_1: (e_1 \lor r_1 \lor r_2)$ $C_2: (e_1 \lor e_2 \lor r_1 \lor r_2 \lor \lnot r_3)$
                  \item[] $C_3: (\lnot e_2 \lor \lnot e_3 \lor r_2 \lor \lnot r_3)$ $C_4: (\lnot e_1 \lor e_3 \lor r_3)$
              \end{itemize}
        \item $\as_1=\lnot e_1 \lnot e_2 \lnot e_3$ selects $\{C_1,C_2\}$
        \item $C_1^Y$ subsumes $C_2^Y$: remove $C_2$ from the set of selected clauses
              \begin{itemize}
                  \item Strengthen the learnt clause to $(\lnot s_1)$
              \end{itemize}
        \item Subsumption among $\cy$ clauses is \textit{induced} by clause selection
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Partial Assignment Pruning}
    \begin{itemize}
        \item $C_L=\bigvee\limits_{C\in\pcf{\pf}{\as}}\lnot\sv{C}=\bigvee\limits_{C\in\pcf{\pf}{\as}}\cx$
        \item Discard literals from $C_L$ by model counting
        \item Recall $\Qf=\exists e_1,\exists e_2,\exists e_3,\random{0.5} r_1,\random{0.5} r_2,\random{0.5} r_3.\pf$ with
              \begin{itemize}
                  \item[] $C_1: (e_1 \lor r_1 \lor r_2)$ $C_2: (e_1 \lor e_2 \lor r_1 \lor r_2 \lor \lnot r_3)$
                  \item[] $C_3: (\lnot e_2 \lor \lnot e_3 \lor r_2 \lor \lnot r_3)$ $C_4: (\lnot e_1 \lor e_3 \lor r_3)$
              \end{itemize}
        \item $\as_1=\lnot e_1 \lnot e_2 \lnot e_3$: $C_L=(\lnot s_1\lor\lnot s_2)=(e_1\lor e_2),\spb{\pcf{\Qf}{\as_1}}=0.75$
              \begin{itemize}
                  \item Can we discard $e_2$ from $C_L$?
                  \item $(e_1)$ blocks $\as$ that selects $C_1$: $\spb{\pcf{\Qf}{\as}}\leq\spb{C_1}=0.75\leq\spb{\pcf{\Qf}{\as_1}}$
              \end{itemize}
        \item Count weight of selected clauses and compare to current maximum
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{ER-SSAT Solving}
    {\scriptsize
        \begin{algorithmic}[1]
            \REQUIRE $\Qf=\exists X,\random{} Y.\pf(X,Y)$
            \ENSURE $\spb{\Qf}$
            \STATE $\select(X,S) := \bigwedge\limits_{C\in\pf}(\sv{C}\equiv\lnot\cx)\land\bigwedge\limits_{\text{pure }l: \vl{l}\in X}l$\label{code:erssat-init-select}
            \STATE $prob := 0$
            \STATE $\texttt{s-table} := \texttt{BuildSubsumptionTable}(\pf)$\label{code:erssat-subsume-table}
            \WHILE{($\sat{\select}$)}
            \STATE $\as := \model{\select}$ (discarding the selection variables)
            \IF{($\sat{\pcf{\pf}{\as}}$)}
            \STATE $\as' := \texttt{SelectMinimalClauses}(\pf,\select)$\label{code:erssat-minimal-clauses}
            \STATE $\varphi := \texttt{RemoveSubsumedClauses}(\pcf{\pf}{\as'},\texttt{s-table})$\label{code:erssat-subsume-clauses}
            \STATE $prob := \max\{prob,\texttt{ComputeWeight}(\random{} Y.\varphi)\}$\label{code:erssat-wmc}
            \STATE $C_S := \bigvee\limits_{C\in\varphi}\lnot\sv{C}$
            \STATE $C_L := \texttt{DiscardLiterals}(\pf,C_S,prob)$\label{code:erssat-discard-literals}
            \ELSE
            \STATE $C_L := \texttt{MinimalConflicting}(\pf,\as)$
            \ENDIF
            \STATE $\select := \select \land C_L$
            \ENDWHILE
            \RETURN $prob$
        \end{algorithmic}
    }
\end{frame}

\begin{frame}
    \frametitle{Computational Complexity of DSSAT}
    \begin{block}{Theorem: NEXPTIME-Completeness of DSSAT}
        The decision version of DSSAT is NEXPTIME-complete
        \begin{itemize}
            \item DSSAT is NEXPTIME
            \item DSSAT is NEXPTIME-hard
        \end{itemize}
    \end{block}
    \begin{block}{Proof Sketch}
        \begin{itemize}
            \item NEXPTIME
                  \begin{enumerate}
                      \item nondeterministically construct a set of Skolem functions $\skf$
                      \item compute $\spb{\pcf{\Qf}{\skf}}$ and compare it with the threshold $\theta$
                  \end{enumerate}
            \item NEXPTIME-hard: DQBF $\leq_P$ DSSAT
                  \abovedisplayskip=0pt
                  \begin{align*}
                      \Qf_Q & = \forall x_1, \ldots, \forall x_n, \exists y_1(D_{y_1}), \ldots, \exists y_m(D_{y_m}).\pf           \\
                      \Qf_S & = \random{0.5} x_1, \ldots, \random{0.5} x_n, \exists y_1(D_{y_1}), \ldots, \exists y_m(D_{y_m}).\pf
                  \end{align*}
                  Claim: $\Qf_Q$ is satisfiable if and only if $\spb{\pcf{\Qf_S}{\skf}} \geq 1$ for some $\skf$
        \end{itemize}
    \end{block}
\end{frame}

\begin{frame}
    \frametitle{Approximate E-MAJSAT Solving: \erssatb on \textit{MPEC}}
    \begin{table}[ht]
        \centering
        \scriptsize
        \pgfplotstabletypeset[
            every head row/.style={before row={\toprule
                            & \multicolumn{4}{c}{\dcssat} & \multicolumn{8}{c}{\erssatb}\\},after row=\midrule},
            every last row/.style={after row=\bottomrule},
            empty cells with={--},
            formula column/.list={0},
            time column/.list={1,3},
            prob column/.list={2,4},
            lbound column/.list={5},
            lbtime column/.list={6}
        ]
        {exist-random-ssat/parsed-MPEC-erssatb.csv}
    \end{table}
\end{frame}

\begin{frame}
    \frametitle{Modeling Decentralized POMDP}
    \begin{center}
        \input{fig/dependency-ssat/dec-pomdp-formulas.tex}
    \end{center}
\end{frame}